from .CoordinateRange import CoordinateRange
import numpy as np
from abc import ABC, abstractclassmethod

class TemplateNotGenerated(Exception):
    pass

class ComplexSet(ABC):
    """Abstract base class for complex sets.

    Args:
        iterations (int): The maximum number of iterations for this set generation.
        coord_range (coordinaterange) ((float, float), (float, float)): X and Y range values, respectively.
        xy_vals (tuple) (int, int): How many intervals to split the x and y axis into.
        name (str, optional): Name of the set, usually called by inherited classes.

    Attributes:
        template (numpy.ndarray): A grid of complex numbers to match the x and y values given across the given XY ranges.
        name (str): The name of the set.
        data (numpy.ndarray): The current set data during the generation process.
        iteration (int): The current iteration during the generation process.
        coord_range (coordinaterange) ((float, float), (float, float)): The XY range of the set generation.
        max_iterations (int): The maximum number of iterations for the set generation.
        mask (numpy.ndarray): Grid of boolean values focusing only on set numbers that haven't diverged.
     
    """
    def __init__(self, iterations:int, coord_range:CoordinateRange, xy_vals:tuple, name='Generic'):
        self._set = None
        self._setmask = None
        self._coord_range = coord_range
        self._max_iterations = iterations
        self._name = name
        self._iteration = 0
        self._set_template = self.generate_template(xy_vals[0], xy_vals[1])

    @property
    def template(self) -> np.ndarray:
        """numpy.ndarray: The complex grid template to use for set generation."""
        return self._set_template
    
    @property
    def name(self) -> str:
        """str: Name of the set."""
        return self._name
    
    @name.setter
    def name(self, name:str):
        self._name = name
    
    @property
    def data(self) -> np.ndarray:
        """numpy.ndarray: Data generated by set generation."""
        return self._set
    
    @data.setter
    def data(self, datagrid:np.ndarray):
        self._set = datagrid
    
    @property
    def iteration(self) -> int:
        """int: Current iteration during set generation."""
        return self._iteration
    
    @iteration.setter
    def iteration(self, i:int):
        self._iteration = i
    
    @property
    def coord_range(self) -> CoordinateRange:
        """coordinaterange: The XY ranges of the set generation."""
        return self._coord_range
    
    @coord_range.setter
    def coord_range(self, coord_range:CoordinateRange):
        self._coord_range = coord_range

    @property
    def max_iterations(self) -> int:
        """int: Maximum iterations for set generation."""
        return self._max_iterations
    
    @max_iterations.setter
    def max_iterations(self, iterations:int):
        self._max_iterations = iterations
    
    @property
    def mask(self) -> np.ndarray:
        """numpy.ndarray: Mask to determine what values to compute."""
        return self._setmask

    @mask.setter
    def mask(self, setmask:np.ndarray):
        self._setmask = setmask
    
    def generate_template(self, xVals:int, yVals:int):
        """Genereates a complex template to use in the set generation.

        Args:
            xVals (int): The number of intervals to split the real axis into.
            yVals (int): The number of intervals to split the imaginary axis into

        returns:
            (numpy.ndarray): A grid of complex numbers to match the x and y values given across the given XY ranges.
        
        """

        xRange = self.coord_range.get_xRange()
        yRange = self.coord_range.get_yRange()
        
        real_parts = np.linspace(xRange[0], xRange[1], xVals)
        imag_parts = np.linspace(yRange[0], yRange[1], yVals)
        real, imag = np.meshgrid(real_parts, imag_parts, indexing="xy")

        pointdt = np.dtype([('point', np.complex128), ('divergence', np.uint32)])

        complex_grid = np.zeros((yVals, xVals), dtype=pointdt)
        complex_grid['point'].real = real
        complex_grid['point'].imag = imag

        self._set_template = complex_grid
        return complex_grid

    def generate_set(self):
        """Genereates the full complex set up to the maximum number of iterations.

        Args:
            xVals (int): The number of intervals to split the real axis into.
            yVals (int): The number of intervals to split the imaginary axis into

        returns:
            data (numpy.ndarray): The final set data after the generation process.
        
        """
        set_ = iter(self)
        for _ in range(0, self.max_iterations):
            next(set_)
        
        return set_.data

    def __iter__(self):
        """Sets up the set generation stage upon creating an iterator."""
        self.data = np.zeros_like(self.template)
        self.mask = np.ones_like(self.template, dtype=bool)
        self.generate_template(self.template.shape[1], self.template.shape[0])
        return self

    @abstractclassmethod
    def __next__(self):
        """To be overridden by implementation."""
        pass